#!/usr/bin/env python
# -*- coding: utf-8 -*-

import math
import random
import copy
import time
import numpy as np
import rospy
import rospkg
import tf
from geometry_msgs.msg import Twist, PoseStamped
from nav_msgs.msg import Odometry
from tf.transformations import quaternion_from_euler
from pi_trees_ros.pi_trees_ros import *
from controller import Controller
from decision.msg import EnemyPos
from roborts_msgs.msg import GimbalAngle, GimbalRate, ShootInfo, ShootState, TwistAccel
from Battle_tmp import BattleEnv

# TODO reconstrcut the code

class TwistControl():
    def __init__(self, move_x, move_y, move_z, angular_z):
        self.Twist = Twist()
        self.Twist.linear.x = move_x
        self.Twist.linear.y = move_y
        self.Twist.linear.z = move_z
        self.Twist.angular.x = 0
        self.Twist.angular.y = 0
        self.Twist.angular.z = angular_z

class BlackBoard():
    def __init__(self):
        self.search_state_flag = False


        self.sended_close = False
        self.sended_far = False
        self.sended_beated = False
        self.sended_follow = False
        self.sended_patrol = False
        self.sended_blocked = False
        self.follow_flag = 0  # 0:跟随；1：左转；2：右转
        self.patrol_flag = 0  # 0:第一个点; 1：第二个点； 2：第三个点...
        self.patrol_flag1 = 0  # 0:先自旋360； 1：开始ptl
        self.patrol_flag2 = 0  # ptl点
        self.leftarea = False
        self.search_state = False

        self.goallastforptl_x = 0
        self.goallastforptl_y = 0

        self.Blocked = False
        self.Blocked_Prevent_close = False
        self.Blocked_Prevent_far = False
        self.Blocked_Prevent_follow = False
        self.Blocked_Prevent_patrol = False
        self.Blocked_excuteflag = 0  # 0:转正；1：推；2：拯救点
        self.BlockedPoseSaveX = 0
        self.BlockedPoseSaveY = 0
        self.BlockedPoseSaveYaw = 0
        self.Blocked_GoalYaw = 0

        self.get_buff_time = 0  # 到了6s就执行抢符
        self.get_buff_time_flag = False  # 不要重复计时标志位

        # 定义拯救点数组:5个点
        self.PreRescuePoint = ((1.35, 2.6, 45), (2.25, 4.5, -45),
                               (6.65, 2.4, -135), (5.75, 0.5, 135))
        self.RescuePoint = ((4, 2.5, 0), (4.8, 1.8, 179), (3.2, 3.2, 0))
        self.avoidloop_far = 0
        self.avoidloop_follow = 0
        self.avoidloop_patrol = 0

        self.rotate_at_begining = True 


class BuildTree():
    def __init__(self):
        self.blackboard = BlackBoard()
        rate = rospy.Rate(30)
        NORMALBEHAVE = Selector("NORMALBEHAVE")
        ROTATE = Sequence("ROTATE")
        SUPPLY = Sequence("SUPPLY")
        BUFF = Sequence("GOTOBUFF")
        SEARCH_REGION = Sequence("SEARCH")
        FOLLOW = Sequence("FOLLOW")
        
        NORMALBEHAVE.add_child(ROTATE)
        NORMALBEHAVE.add_child(SUPPLY)
        # NORMALBEHAVE.add_child(BUFF)
        NORMALBEHAVE.add_child(SEARCH_REGION)
        NORMALBEHAVE.add_child(FOLLOW)

        ISROTATE = IsRotate("ISROTATE", blackboard=self.blackboard)
        ROTATE_DO = Rotate_Do("ROTATE_DO",blackboard=self.blackboard)
        ROTATE.add_child(ISROTATE)
        ROTATE.add_child(ROTATE_DO)

        ISSUPPLY = IsSupply("ISSUPPLY", blackboard=self.blackboard)
        SUPPLY_DO = Supply_Do("SUPPLY_DO",blackboard=self.blackboard)
        SUPPLY.add_child(ISSUPPLY)
        SUPPLY.add_child(SUPPLY_DO)
        
        ISGOTOBUFF = IsGOTOBUFF("ISGOTOBUFF", blackboard=self.blackboard)
        GOTOBUFF = GotoBuff("GOTOBUFF", blackboard=self.blackboard)
        BUFF.add_child(ISGOTOBUFF)
        BUFF.add_child(GOTOBUFF)


        ISSEARCH = IsSearch("ISSERARCH", blackboard=self.blackboard)
        SEARCH = Search("SEARCH", blackboard=self.blackboard)
        SEARCH_REGION.add_child(ISSEARCH)
        SEARCH_REGION.add_child(SEARCH)

        ISFOLLOW = IsFollow("ISFOLLOW", blackboard=self.blackboard)
        FOLLOW_SHOOT = Follow_Shoot("FOLLOW_SHOOT", blackboard=self.blackboard)
        FOLLOW.add_child(ISFOLLOW)
        FOLLOW.add_child(FOLLOW_SHOOT)


        rospy.loginfo("NORMALBEHAVE Tree")
        print_tree(NORMALBEHAVE)
        
        while not rospy.is_shutdown():
            NORMALBEHAVE.status = NORMALBEHAVE.run()
            rate.sleep()

class IsRotate(Task):
    def __init__(self, name, blackboard = None):
        super(IsRotate,self).__init__(name)
        self.name = name
        self.blackboard = blackboard
	
    
    def run(self):
        if self.rotate_at_begining == True:
            return TaskStatus.SUCCESS
        else:
            return TaskStatus.FAILURE

    def reset(self):
        pass

class Rotate_Do(Task):
    def __init__(self, name, blackboard = None):
        super(Rotate_Do,self).__init__(name)
        self.name = name
        self.blackboard = blackboard
        
    def run(self):
        if env.GAME_STATUS != 4:
            return TaskStatus.SUCCESS
        else:
            rotate_start_time = rospy.Time.now().secs
            while rospy.Time.now().secs - rotate_start_time < 5:
                ctrl.send_vel(TwistControl(0, 0, 0, 1).Twist)
            self.rotate_at_begining = False
            return TaskStatus.FAILURE

    def reset(self):
        pass


class IsSupply(Task):
    def __init__(self, name, blackboard = None):
        super(IsSupply,self).__init__(name)
        rospy.loginfo("issupply ready")
        self.name = name
        self.blackboard = blackboard

    def run(self):
        #rospy.INFO("NEED SUPPLY!!!")
        if env.supply_needed == True:
            #rospy.logwarn("Got supply singal")
            return TaskStatus.SUCCESS
        else:
            return TaskStatus.FAILURE

    def reset(self):
        pass

class Supply_Do(Task):
    def __init__(self, name, blackboard = None):
        super(Supply_Do,self).__init__(name)
        rospy.loginfo("supply ready")
        self.name = name
        self.blackboard = blackboard
        
    def run(self):
        rospy.logwarn("got it ")
        if env.breaksupply:
            if env.isActionAvaliable(env.breakpoint[0], env.breakpoint[1], env.breakpoint[2]):
                env.send_goal(env.navgoal)
                env.supply_needed = False
                env.sendgoalresult = False
                env.go_point_num = 0
                env.breaksupply = False
                return TaskStatus.FAILURE
        else:
            if env.go_point_num == 2:
                result = self.nav_to_default_supply_point()
                if result:
                    rospy.logwarn("default supply done")
                    env.supply_needed = False
                    env.sendgoalresult = False
                    env.go_point_num = 0
                    return TaskStatus.SUCCESS
                else:
                    rospy.logwarn("default supply fail")
                    env.supply_needed = False
                    env.sendgoalresult = False
                    env.go_point_num = 0
                    return TaskStatus.FAILURE
            else:
                while env.supply_needed :
                    #supplypoints = env.supplypoint_list[env.supply_tagnum]
                    #rospy.loginfo(supplypoints)
                    supplypoint = env.supplypoint_list[env.go_point_num]
                    rospy.logwarn(supplypoint)
                    
                    if env.isActionAvaliable(supplypoint[0], supplypoint[1], supplypoint[2]):
                        env.send_goal(env.navgoal)
                        goal_start = time.time()

                        if env.sendgoalresult:
                            env.tag_info = {'tag_detected': False, 'x': 0, 'z': 0, 'pitch': 0, 'distance': 0 }
                            rospy.loginfo("got the supply area!")
                            find_start = time.time()

                            while env.tag_info['tag_detected'] == False or abs(env.tag_info['pitch']) > 2: 
                                rotate_end = time.time()
                                if rotate_end - find_start < 4:
                                    ctrl.send_vel(cmdvel_slowyoutwist)
                                elif rotate_end - find_start >= 4 and rotate_end - find_start < 12:
                                    ctrl.send_vel(cmdvel_slowzuotwist)
                                else:
                                    if env.go_point_num == 0:
                                        env.go_point_num = 1
                                        rospy.logwarn("tag not found!!!!!!! go to the next point")
                                        return TaskStatus.FAILURE
                                    else:
                                        env.go_point_num = 2
                                        return TaskStatus.FAILURE
                                        
                            while abs(env.tag_info['x']) > 0.1:
                                # cmdvel_slowzuoyou= Twist()
                                # cmdvel_slowzuoyou.linear.x = 0
                                # cmdvel_slowzuoyou.linear.y = 0.2*(env.tag_info['x']/abs(env.tag_info['x']))
                                # cmdvel_slowzuoyou.linear.z = 0
                                # cmdvel_slowzuoyou.angular.x = 0
                                # cmdvel_slowzuoyou.angular.y = 0
                                # cmdvel_slowzuoyou.angular.z = 0
                                if env.ARMOR_HIT_NUM != -1 and env.REMAIN_HP < 30: 
                                    env.breaksupply = True
                                    return TaskStatus.FAILURE
                                else:
                                    # ctrl.send_vel(cmdvel_slowzuoyou)
                                    ctrl.send_vel(TwistControl(0, 0.2*(env.tag_info['x']/abs(env.tag_info['x'])), 0, 0).Twist)
                                    rospy.logwarn("zuoyou distance: ")
                                    rospy.loginfo(env.tag_info['x'])

                            while env.tag_info['z'] > 0.5:
                                # cmdvel_slowtotag = Twist()
                                # cmdvel_slowtotag.linear.x = -0.2
                                # cmdvel_slowtotag.linear.y = 0
                                # cmdvel_slowtotag.linear.z = 0
                                # cmdvel_slowtotag.angular.x = 0
                                # cmdvel_slowtotag.angular.y = 0
                                # cmdvel_slowtotag.angular.z = 0
                                if env.ARMOR_HIT_NUM != -1 and env.REMAIN_HP < 30:
                                    env.breaksupply = True
                                    return TaskStatus.FAILURE
                                else:
                                    # ctrl.send_vel(cmdvel_slowtotag)
                                    ctrl.send_vel(TwistControl(-0.2, 0, 0, 0).Twist)
                                    rospy.logwarn("moving!!!")
                                    rospy.loginfo(env.tag_info['z'])

                            rospy.logwarn("reached supply area")
                            rospy.loginfo("************supplying**************")
                            env.supplytalker.publish(True)
                            rospy.sleep(3)
                            rospy.logwarn("supplying done")
                            env.supply_needed = False
                            env.sendgoalresult = False
                            self.go_point_num = 0
                            return TaskStatus.SUCCESS

                        else:
                            goal_end = time.time()
                            if goal_end - goal_start > 10 :
                                if env.go_point_num == 0:
                                    env.go_point_num = 1
                                    return  TaskStatus.FAILURE
                                else :
                                    env.go_point_num = 2
                                    return TaskStatus.FAILURE
                            else:
                                pass
                    else:
                        if env.go_point_num == 0:
                            env.go_point_num = 1
                            rospy.logwarn("tag not found!!!!!!! go to the next point")
                            return TaskStatus.FAILURE
                        else:
                            env.go_point_num = 2
                            return TaskStatus.FAILURE

    
    def nav_to_default_supply_point(self):
        supplypoint = env.supplypoint_default
        if env.isActionAvaliable(supplypoint[0], supplypoint[1], supplypoint[2]):
            env.send_goal(env.navgoal)
            go_default_start = time.time()

            if  env.sendgoalresult:
                rospy.logwarn("reached default supply area")
                rospy.loginfo("************supplying**************")
                env.supplytalker.publish(True)
                rospy.sleep(3)
                rospy.logwarn("supplying done")
                return True

            else:
                go_default_end = time.time()
                if go_default_end - go_default_start > 10:
                    rospy.logwarn("!!!!!!!the area is not reachable!!!!!!!!!!!!supply failed!!!!!!!!!!!")
                    return False
        else:
            rospy.logwarn('Action is not avaliable!!!!!!!')
            return False
        


class IsGOTOBUFF(Task):
    def  __init__(self, name, blackboard=None):
        super(IsGOTOBUFF, self).__init__(name)
        self.name = name
        self.blackboard = blackboard
    def run(self):
        if env.RED_BONUS_STATUS==0 and not env.sudden_find and env.ROBOT_BONUS==0 and (env.ammo_num >=16 or env.REMAIN_HP >=1000): 
            return TaskStatus.SUCCESS
        else:
            return TaskStatus.FAILURE

    def reset(self):
        pass

class GotoBuff(Task):
    def __init__(self, name, blackboard=None):
        super(GotoBuff, self).__init__(name)
        self.name = name
        self.blackboard = blackboard
        self.time1 =0

    def run(self):
        print ('************************ENTER_GotoBuff**************************')
        Point_BUFF = [6.3, 1.75, 150]
        env.goal_x, env.goal_y, env.goal_yaw = Point_BUFF[0],Point_BUFF[1],Point_BUFF[2]
        while env.RED_BONUS_STATUS==0 and env.ROBOT_BONUS==0 and (env.ammo_num >=16 or env.REMAIN_HP >=1000):
            try:
                rospy.loginfo("BUFF------going to BUFF!!!!")
                if self.gotoBUFF() == 1:
                    return TaskStatus.FAILURE             
                if env.RED_BONUS_STATUS == 1:
                    start_buff = rospy.Time.now().secs
                    env.enterDodge()
                    if env.RED_BONUS_STATUS==1:
                        while env.RED_BONUS_STATUS==1 and(6.2<=env.robot_pose['x']<=6.4)  and (1.6<=env.robot_pose['y']<=1.9) and env.ROBOT_BONUS==0:
                            self.WatingBUFF()
                        env.outDodge()
                        rospy.loginfo("BUFF------************RED_BONUS_STATUS {}".format(env.RED_BONUS_STATUS))
                        if env.RED_BONUS_STATUS == 2:
                            return TaskStatus.SUCCESS
                    if env.RED_BONUS_STATUS!=1:
                        while rospy.Time.now().secs - start_buff < 6:
                            self.WatingBUFF()
                        env.outDodge()
                        rospy.loginfo("BUFF------************RED_BONUS_STATUS {}".format(env.RED_BONUS_STATUS))
                        if env.RED_BONUS_STATUS!=2:
                            return TaskStatus.FAILURE
                else:
                    rospy.loginfo("BUFF------Can't arrive buff position !!!-----Go back!!!")
                    return TaskStatus.FAILURE
            except rospy.ROSInterruptException:
                pass

    def gotoBUFF(self):
        while not rospy.is_shutdown() and  env.RED_BONUS_STATUS==0:
            if env.isActionAvaliable(env.goal_x, env.goal_y, env.goal_yaw) and env.ROBOT_BONUS==0 and env.RED_BONUS_STATUS==0 and env.ammo_num >=16:
                env.send_goal_buff(env.navgoal)
                if env.is_cancel_goal_inbuff_flag==1:
                    rospy.loginfo("BUFF------the goto buff has been cancled!!!!")#识别到则cancle返回为1
                    return 1
                if (6.2<=env.robot_pose['x']<=6.4)  and (1.6<=env.robot_pose['y']<=1.9):
                    env.RED_BONUS_STATUS=1
                    rospy.loginfo("BUFF------robot is in the buff_point!!")
            elif env.isActionAvaliable(env.goal_x, env.goal_y, env.goal_yaw) and env.ROBOT_BONUS==0 and env.RED_BONUS_STATUS==0 and env.ammo_num <16:
                env.send_goal_force(env.navgoal)
                rospy.loginfo("BUFF------robot will go to the BUFF!!!!")
            else:
                rospy.loginfo("BUFF------the BUFF point %s cannot avaliable!!!!!!!!!!!!")
                #break
        return 0

    def WatingBUFF(self):
        rospy.loginfo("BUFF------robot is waiting in the buff_point!!")
         #进行摆尾打击
        # if env.detection_result_stable:
        #     if env.ARMOR_HIT_NUM !=-1:
        #         rospy.loginfo("robot is hiting enemy and robot is been hit ！！！")
        # elif not env.detection_result_stable:
        #      if env.ARMOR_HIT_NUM !=-1:
        #         rospy.loginfo("robot is been hit !!! ")
        #         env.goal_x = env.robot_pose['x']
        #         env.goal_y = env.robot_pose['y']
        #         if env.ARMOR_HIT_NUM == 0:#敌人在正前方，看见直接还击
        #             env.goal_yaw = env.robot_pose['theta']
        #         elif env.ARMOR_HIT_NUM == 1:#敌人在后方，向后转
        #             env.goal_yaw = env.robot_pose['theta'] + 178
        #         elif env.ARMOR_HIT_NUM == 2:#敌人在左侧，向左转
        #             env.goal_yaw = env.robot_pose['theta'] + 30
        #         elif env.ARMOR_HIT_NUM == 3:#敌人在右侧，向右转
        #             env.goal_yaw = env.robot_pose['theta'] - 120 
        #         if env.isActionAvaliable(env.goal_x, env.goal_y, env.goal_yaw) :
        #             env.send_goal(env.navgoal)
        #else:#休眠0.05
            #rospy.sleep(0.05)

class IsSearch(Task):
    def __init__(self, name, blackboard=None):
        super(IsSearch, self).__init__(name)
        self.name = name
        self.blackboard = blackboard

    def run(self):
        # rospy.logwarn('search!!!!!!!! distance:{}, result:{}'.format(env.enemy_pose.enemy_dist, env.detection_result))
        # if env.enemy_pose.enemy_dist == 0: # 没有检测敌人
        if not env.detection_result_stable: # 没有稳定检测敌人
            return TaskStatus.SUCCESS
        else:
            return TaskStatus.FAILURE

    def reset(self):
        pass

class Search(Task):
    def __init__(self, name, blackboard=None):
        super(Search, self).__init__(name)
        self.name = name
        self.blackboard = blackboard
        self.location_num = 0
        self.search_points = []
        self.cancel_dist = 2

    def run(self):
        if env.detection_result:
            if self.detectedBehavior() == 0:
                # return False
                return TaskStatus.FAILURE
            elif self.detectedBehavior() == 1:
                # return True
                return TaskStatus.SUCCESS

        self.locationNum([env.robot_pose['x'], env.robot_pose['y']]) # 常规搜索 = 就近区域搜索 + 临近区域搜索
        self.updateSearchPoints()

        while self.searchRegion(self.search_points): # 搜索途中未发现敌人
            # 全图区域顺序搜索
            self.location_num += 1
            self.location_num %= len(env.search_regions)
            self.updateSearchPoints()
            # TODO 区域间切换搜索顺序
            # self.location_num += random.randint(-1, 1) # 随机临近区域
        print ("-----------------out_of_search_regions----------------")
        # return True
        return TaskStatus.FAILURE

    def detectedBehavior(self):
        rospy.logwarn("detect %s, stable %s" %(env.detection_result, env.detection_result_stable))
        rospy.logwarn("----------detect enemy at {0},{1}".format(env.enemy_position['x'], env.enemy_position['y']))

        print ("-------------start roation!!!!------------")
        env.pointToEnemy()
        print ("-------------after roation!!!!------------")

        if env.enemy_pose.enemy_dist > 0 and env.enemy_pose.enemy_dist < env.SEARCH_stop_dist:
            env.global_path_planner_action_client.cancel_all_goals()
            env.local_path_planner_action_client.cancel_all_goals()
            ctrl.send_vel(TwistControl(0, 0, 0, 0).Twist)
            rospy.logwarn("---------START_STOP_for_dist: {}----------".format(env.enemy_pose.enemy_dist))
            return 0 # enter into follow

        print ("-----------dist is long: {}".format(env.enemy_pose.enemy_dist)+'-------------')
        if env.isActionAvaliable(env.enemy_position['x'], env.enemy_position['y'], math.degrees(env.point_to_enemy_radian)):
            rospy.loginfo("Goto the detected area and search!")
            
            env.SEARCH_cancel_flag = 0
            env.send_goal_in_search(env.navgoal)
            if env.SEARCH_cancel_flag == 1: # detect_out
                ctrl.send_vel(TwistControl(0, 0, 0, 0).Twist)
                rospy.logwarn("detect enemy during goto near area!!!!!")
                return 1 # enter into behavior_tree
            if env.SEARCH_cancel_flag == 2: # hit_out
                env.pointToEnemy()
                env.ARMOR_HIT_NUM = -1
                return 1
            if env.SEARCH_cancel_flag == 3: # close_out
                ctrl.send_vel(TwistControl(0, 0, 0, 0).Twist)
                rospy.logwarn("-------------STOP_for_dist:{}--------------".format(env.enemy_pose.enemy_dist))

        return -1

    def updateSearchPoints(self):
        self.search_points = []
        # 区域内固定顺序搜索：
        # self.search_points = env.search_regions[self.location_num]
        # 区域内随机顺序搜索：
        # self.search_points = copy.deepcopy(env.search_regions[self.location_num])
        # random.shuffle(self.search_points)
        # 区域内就近原则搜索：
        self.closeSearch([env.robot_pose['x'], env.robot_pose['y']], copy.deepcopy(env.search_regions[self.location_num]))

    def searchRegion(self, point_list):
        # TODO: 考虑更多退出条件，血少或弹少
        rospy.loginfo("search region is {}".format(self.location_num))
        for search_goal in point_list: 
            if env.isActionAvaliable(search_goal[0], search_goal[1], search_goal[2]):
                rospy.loginfo("Goto point {0}, {1}".format(search_goal[0], search_goal[1]))
                
                env.SEARCH_cancel_flag = 0
                env.send_goal_in_search(env.navgoal)
                if env.SEARCH_cancel_flag == 1: # detect_out
                    ctrl.send_vel(TwistControl(0, 0, 0, 0).Twist)
                    rospy.logwarn("Detect during search !!!")
                    return False # enter into behavior_tree
                if env.SEARCH_cancel_flag == 2: # hit_out
                    env.pointToEnemy()
                    env.ARMOR_HIT_NUM = -1
                    return False
                if env.SEARCH_cancel_flag == 3: # close_out
                    ctrl.send_vel(TwistControl(0, 0, 0, 0).Twist)
                    rospy.logwarn("-------------STOP_for_close--------------")
                    return False
                if env.SEARCH_cancel_flag == 4:
                    continue

            else:
                rospy.logwarn("cannot goto the point")
        return True

    def locationNum(self, self_pose): # 分解地图4个区域，顺时针排序
        if self_pose[1] < 2.5:
            if self_pose[0] < 3.5:
                self.location_num = 0
            else:
                self.location_num = 3
        elif self_pose[0] < 4.5:
            self.location_num = 1
        else:
            self.location_num = 2

    def closeSearch(self, self_pose, point_list): # 将point_list按照距离self_pose的逐点最近排序
        if len(point_list) != 1:
            dist_min = 99
            for p in point_list:
                dist = math.hypot((self_pose[0] - p[0]), (self_pose[1] - p[1]))
                if dist < dist_min:
                    dist_min = dist
                    point_temp = p
            self.search_points.append(point_temp)
            point_list.remove(point_temp)
            self.closeSearch(point_temp, point_list) # 递归
        else:
            return self.search_points.append(point_list[0])

class IsFollow(Task):
    def __init__(self, name, blackboard=None):
        super(IsFollow, self).__init__(name)
        self.name = name
        self.blackboard = blackboard

    def run(self):
        if env.detection_result_stable == True:
            #rospy.loginfo('FALLOW: {}'.format(env.enemy_pose.enemy_dist))
            return TaskStatus.SUCCESS
        else:
            return TaskStatus.FAILURE

    def reset(self):
        pass


class Follow_Shoot(Task):
    def __init__(self, name, blackboard=None):
        super(Follow_Shoot, self).__init__(name)
        self.name = name
        self.blackboard = blackboard
        self.goal_x = 0.01
        self.goal_y = 0.01
        self.goal_yaw = 0
        self.x = 0
        self.y = 0
        self.yaw = 0
        self.keep_length = 0
        self.time1 = 0
        self.enemy_last_x = 0
        self.enemy_last_y = 0
        self.enemy_last_yaw = 0
        self.change_angle_list = [0, 0, 5, 5, 15, 15, 30, 30, 50, 50, 75, 75]

    def run(self):
        rospy.logwarn('enter follow_shoot')
        while not env.supply_needed: # 不需补弹
            if env.detection_result == False:
                # env.global_path_planner_action_client.cancel_all_goals()
                # env.local_path_planner_action_client.cancel_all_goals()
                ctrl.send_vel(TwistControl(0, 0, 0, 0).Twist)
                return TaskStatus.SUCCESS
             
            if self.enemy_big_change() == False:
                if self.normalizeDegree(env.enemy_yaw_chassis) > 0:
                    self.goal_yaw = math.radians(env.robot_pose['theta']) + env.enemy_yaw_chassis - math.radians(35)
                else:
                    self.goal_yaw = math.radians(env.robot_pose['theta']) + env.enemy_yaw_chassis + math.radians(35)
                if env.isActionAvaliable(env.robot_pose['x'], env.robot_pose['y'], 
                                            self.normalizeDegree(self.goal_yaw)):# 指向敌人,误识别
                    env.send_goal_force(env.navgoal)
                #ctrl.gimbal_mode_switch(2) # 摆尾
                #ctrl.chassis_mode_switch(1) 
                continue
            #ctrl.gimbal_mode_switch(0) # track
            #ctrl.chassis_mode_switch(0)

            self.count = 0
            self.change_angle = 0
            self.goal_x = 0.01
            self.goal_y = 0.01
            self.goal_yaw = 0

            if self.follow_goal(env.enemy_pose.enemy_dist, env.enemy_pose.enemy_yaw, env.robot_pose['x'], env.robot_pose['y']) == False:
                return TaskStatus.SUCCESS # 无法跟随 重新执行树

            if env.isActionAvaliable(self.goal_x, self.goal_y,
                                            self.normalizeDegree(self.goal_yaw)):  # 判断目标点是否可行
                env.send_goal_in_follow(env.navgoal)
                rospy.loginfo('r0: is follow !!!!!!!     %s,%s,%s' %
                                    (self.goal_x, self.goal_y, self.normalizeDegree(self.goal_yaw)))
                self.enemy_last_x = env.enemy_position['x']
                self.enemy_last_y = env.enemy_position['y']
                self.enemy_last_yaw = env.enemy_pose.enemy_yaw
        return TaskStatus.SUCCESS # 弹量不充足 重新执行树
   
    def follow_goal(self, enemy_dist, enemy_yaw, robot_x, robot_y):
        rospy.logerr("---------follow_goal---------")
        if self.close_obstacle(env.enemy_position['x'], env.enemy_position['y'], robot_x, robot_y, 0.4) == True:
            self.keep_length = 0.4

        elif enemy_dist > 0 and enemy_dist < 2.6:
            self.keep_length = 0.6 # 跟随距离
        # elif enemy_dist >= 0.6 and enemy_dist < 1.2:
        #     if env.isActionAvaliable(robot_x,robot_y, 
        #                             math.degrees(enemy_yaw)):# 指向敌人
        #         env.send_goal_force(env.navgoal)
        #     break
        # elif enemy_dist >= 1.2 and enemy_dist < 4:
        #     self.keep_length = 1.2
        while env.isActionAvaliable(self.goal_x, self.goal_y, self.normalizeDegree(self.goal_yaw)) == False:
            self.count += 1
            if self.count > 11:
                rospy.logwarn('!!!!!!  cant follow  !!!!!!!')
                return False     # 无法跟随 重新执行树         
            self.change_angle = math.radians(self.change_angle_list[self.count]) # 旋转角度 radian
                    
            rospy.loginfo("%s" % math.degrees(self.change_angle))
                                        
            self.yaw = enemy_yaw
            if self.count % 2 == 1:      #顺时针
                if enemy_yaw > 0 and enemy_yaw < math.pi/2:
                    self.y = robot_y + enemy_dist * (math.sin(self.yaw) - math.cos(self.yaw) * math.tan(self.yaw - self.change_angle))
                    self.x = robot_x
                    self.dist = enemy_dist * math.cos(self.yaw) / math.cos(self.yaw - self.change_angle)
                    self.yaw = enemy_yaw - self.change_angle # radian

                elif enemy_yaw > math.pi/2 and enemy_yaw < math.pi:
                    self.x = robot_x - enemy_dist * (math.sin(self.yaw - math.pi/2) - math.cos(self.yaw - math.pi/2) * math.tan(self.yaw - math.pi/2 - self.change_angle))
                    self.y = robot_y
                    self.dist = enemy_dist * math.cos(self.yaw - math.pi/2) / math.cos(self.yaw - math.pi/2 - self.change_angle)
                    self.yaw = enemy_yaw - self.change_angle

                elif enemy_yaw > -math.pi/2 and enemy_yaw < 0:
                    self.x = robot_x + enemy_dist * (math.sin(math.pi/2 + self.yaw) - math.cos(math.pi/2 + self.yaw) * math.tan(math.pi/2 + self.yaw -self.change_angle))
                    self.y = robot_y
                    self.dist = enemy_dist * math.cos(self.yaw + math.pi/2) / math.cos(self.yaw - self.change_angle)
                    self.yaw = enemy_yaw - self.change_angle

                else:
                    self.y = robot_y - enemy_dist * (math.sin(math.pi + self.yaw) - math.cos(math.pi + self.yaw) * math.tan(math.pi + self.yaw -self.change_angle))
                    self.x = robot_x
                    self.dist = enemy_dist * math.cos(self.yaw + math.pi) / math.cos(self.yaw + math.pi - self.change_angle)
                    self.yaw = enemy_yaw - self.change_angle

            else:
                if enemy_yaw > 0 and enemy_yaw < math.pi/2:  #逆时针
                    self.x = robot_x + enemy_dist * (math.sin(math.pi/2 - self.yaw) - math.cos(math.pi/2 - self.yaw) * math.tan(math.pi/2 - self.yaw - self.change_angle))
                    self.y = robot_y
                    self.dist = enemy_dist * math.cos(-self.yaw + math.pi/2) / math.cos(math.pi/2 - self.yaw - self.change_angle)
                    self.yaw = enemy_yaw + self.change_angle

                elif enemy_yaw > math.pi/2 and enemy_yaw < math.pi:
                    self.y = robot_y + enemy_dist * (math.sin(math.pi - self.yaw) - math.cos(math.pi- self.yaw) * math.tan(math.pi - self.yaw - self.change_angle))
                    self.x = robot_x
                    self.dist = enemy_dist * math.cos(-self.yaw + math.pi) / math.cos(math.pi - self.yaw - self.change_angle)
                    self.yaw = enemy_yaw + self.change_angle
                    
                elif enemy_yaw > -math.pi/2 and enemy_yaw < 0:
                    self.y = robot_y - enemy_dist * (math.sin(-self.yaw) - math.cos(-self.yaw) * math.tan(-self.yaw -self.change_angle))
                    self.x = robot_x
                    self.dist = enemy_dist * math.cos(-self.yaw) / math.cos(-self.yaw - self.change_angle)
                    self.yaw = enemy_yaw + self.change_angle
                    
                else:
                    self.x = robot_x - enemy_dist * (math.sin(-self.yaw - math.pi/2) - math.cos(-self.yaw - math.pi/2) * math.tan(-self.yaw - math.pi/2 -self.change_angle))
                    self.y = robot_y
                    self.dist = enemy_dist * math.cos(-self.yaw - math.pi/2) / math.cos(-self.yaw - math.pi/2 - self.change_angle)
                    self.yaw = enemy_yaw + self.change_angle
            self.dist = self.dist - self.keep_length
            self.dx = self.dist * math.cos(self.yaw)
            self.dy = self.dist * math.sin(self.yaw)
            self.goal_x = self.x + self.dx
            self.goal_y = self.y + self.dy
            self.goal_yaw = self.yaw

            if env.isReachable(env.enemy_position['x'], env.enemy_position['y'], self.goal_x, self.goal_y) == False or self.close_obstacle(
                env.enemy_position['x'], env.enemy_position['y'], robot_x, robot_y, 0.2) == True:
                self.goal_x = 0.01
                self.goal_y = 0.01
        return True

    def normalizeDegree(self, theta): # 将角度radian归一化为[-180, 180]
        return math.degrees(math.atan2(math.sin(theta), math.cos(theta)))

    def enemy_big_change(self):
        if np.square(self.enemy_last_x - env.enemy_position['x']) + np.square(self.enemy_last_y - env.enemy_position['y']) < 0.025:
            return False
        # if abs(self.normalizeTheta(self.enemy_last_yaw - env.enemy_pose.enemy_yaw)) < 10:
        #     return False
        return True
    
    def close_obstacle(self, enemy_x, enemy_y, robot_x, robot_y, dis_set):
        dis_min = 100
        for i in env.obstacle_conner:
            if self.judge(i[0], i[1], enemy_x, enemy_y, robot_x, robot_y):
                dis = self.dis_point_to_line(i[0], i[1], enemy_x, enemy_y, robot_x, robot_y)
                if dis_min > dis:
                    dis_min = dis
        if dis_min < dis_set:
            return True
        else:
            return False
    
    def dis_point_to_line(self, pointX, pointY, lineX1, lineY1, lineX2, lineY2): # 一般式
        a = lineY2 - lineY1
        b = lineX1 - lineX2
        c = lineX2 * lineY1 - lineX1 * lineY2
        dis = (math.fabs(a*pointX+b*pointY+c)) / (math.pow(a*a+b*b,0.5))
        return dis
    
    def judge(self, pointX, pointY, pointX1, pointY1, pointX2, pointY2):
        if (pointX >= pointX1 and pointX <= pointX2) or (pointX <= pointX1 and pointX >= pointX2):
            if (pointY >= pointY1 and pointY <= pointY2) or (pointY <= pointY1 and pointY >= pointY2):
                return True
            else:
                return False
        else:
            return False

    def reset(self):
        pass


if __name__ == '__main__':
    rospy.loginfo('init')
    rospy.init_node('decision_node')
    ctrl = Controller()
    env = BattleEnv()
    tflistener = tf.TransformListener()
    #ctrl.cmd_fric_wheel_client(True)
    # ctrl.global_path_planner_action_client.wait_for_server(rospy.Duration(0.5))
    # ctrl.local_path_planner_action_client.wait_for_server(rospy.Duration(0.5))

    cmdvel_slowfront = TwistControl(0.205, 0, 0, 0).Twist # 慢速向前命令
    cmdvel_slowback = TwistControl(-0.205, 0, 0, 0).Twist # 慢速向后命令
    cmdvel_slowzuotwist = TwistControl(0, 0, 0, 0.3).Twist # 慢速正转
    cmdvel_slowyoutwist = TwistControl(0, 0, 0, -0.3).Twist # 慢速反转
    cmdvel_middlefront = TwistControl(0.6, 0, 0, 0).Twist # 中速向前命令
    cmdvel_middleback = TwistControl(-0.5, 0, 0, 0).Twist # 中速向后命令
    cmdvel_fastfront = TwistControl(3.5, 0, 0, 0).Twist # 最快速向前命令
    cmdvel_fastleft = TwistControl(0, 3.5, 0, 0).Twist # 最快速向左命令
    cmdvel_stop = TwistControl(0, 0, 0, 0).Twist # 定义静止命令

    rospy.loginfo('Start the ICRA_RM!!!!!!')
    
    rospy.loginfo('Enter the tree')
    tree = BuildTree()  # 已经加buff进入tree        
    rospy.spin()
